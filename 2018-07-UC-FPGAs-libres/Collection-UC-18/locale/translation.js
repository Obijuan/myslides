// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Comb');
gettext('Const');
gettext('Varios');
gettext('Mux');
gettext('Puertas');
gettext('Tablas');
gettext('1-Bit');
gettext('2-Bits');
gettext('4-Bits');
gettext('8-Bit');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1');
gettext('Mux-2-1');
gettext('Mux-4-1-flip');
gettext('Multiplexor de 4 a 1. Implementado en verilog');
gettext('Mux-4-1');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 2 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 2 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 4 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 4 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 8 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 8 bits');
gettext('and');
gettext('Puerta AND');
gettext('and3');
gettext('Puerta AND de 3 entradas');
gettext('nand');
gettext('Puerta NAND');
gettext('nor');
gettext('Puerta NOR');
gettext('not');
gettext('Puerta NOT');
gettext('or');
gettext('Puerta OR');
gettext('xnor');
gettext('Puerta XNOR');
gettext('xor');
gettext('Puerta XOR');
gettext('tabla-1-1');
gettext('Circuito combinacional de 1 entrada y 1 salida');
gettext('tabla-2-1');
gettext('Circuito combinacional de 2 entradas y 1 salida');
gettext('tabla-2-2');
gettext('Circuito combinacional de 2 entradas y 2 salida');
gettext('tabla-3-1');
gettext('Circuito combinacional de 3 entradas y 1 salida');
gettext('tabla-4-1');
gettext('Circuito combinacional de 4 entradas y 1 salida');
gettext('Bits');
gettext('Bus');
gettext('0');
gettext('Un bit constante a 0');
gettext('1');
gettext('Un bit constante a 1');
gettext('02_bits');
gettext('04_bits');
gettext('08_bits');
gettext('Generico');
gettext('Valor genérico constante, de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_0');
gettext('Valor constante 0 para bus de 2 bits');
gettext('Valor_1');
gettext('Valor constante 1 para bus de 2 bits');
gettext('Valor_2');
gettext('Valor constante 2 para bus de 2 bits');
gettext('Valor_3');
gettext('Valor constante 3 para bus de 2 bits');
gettext('Generico');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_00');
gettext('Valor constante 0 para bus de 4 bits');
gettext('Valor_05');
gettext('Valor constante 5 para bus de 4 bits');
gettext('Valor_10');
gettext('Valor constante 10 para bus de 4 bits');
gettext('Valor_15');
gettext('Valor constante 15 para bus de 4 bits');
gettext('Generico');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_000');
gettext('Valor constante 0 para bus de 8 bits');
gettext('Valor_085');
gettext('Valor constante 85 (55h) para bus de 8 bits');
gettext('Valor_170');
gettext('Valor constante 170 (AAh) para bus de 8 bits');
gettext('Valor_255');
gettext('Valor constante 255 para bus de 8 bits');
gettext('Bombeo');
gettext('Bus');
gettext('Motor');
gettext('Pegatinas');
gettext('Recreo');
gettext('Retardo');
gettext('Servos');
gettext('Test');
gettext('Reto 1: ¡Cárgame en la placa y pruébame! :-)');
gettext('Contador ascendente de 4bits, con entrada de cuenta');
gettext('Registro de 4 bits con entrada de load');
gettext('Agregador de 2 buses (2+2)  a bus de 4bits');
gettext('Separador de bus de 4bits en 2 (2 + 2)');
gettext('Registro de 2 bits, con entrada de load');
gettext('Separador de bus de 2bits');
gettext('Agregador de 2 cables a bus de 2bits');
gettext('Biestable D con enable inicializado a 0');
gettext('Biestable tipo D con entrada de enable, inicializado al parámetro INI');
gettext('Biestable D con inicialización paramétrica');
gettext('Multiplexor 2:1 de 1-bit');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Incrementar en 1 el dato de 4 bits');
gettext('Sumador de 4 bits con acarreo de salida');
gettext('Sumador de 4 bits con acarreo de salida y de entrada');
gettext('Sumador de 2 bits con acarreo de salida y de entrada');
gettext('Sumador de 1bit, con arraceo de entrada y salida');
gettext('Semisumador. 2 bits de entrada, saca la suma (S) y el acarreo (C)');
gettext('XOR logic gate');
gettext('Valor constante 1 para bus de 4 bits');
gettext('Valor constante de 4 bits');
gettext('Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)');
gettext('Generar un pulso de reloj al recibir un flanco por la entrada');
gettext('Biestable D inicializado a 0');
gettext('Delay flip-flop');
gettext('Circuito combinacional de 4 entradas y 8 salidas');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('Fijos');
gettext('Corazon_Hz');
gettext('Corazon_Seg');
gettext('Bombear 1 bit con el periodo especificado en el parámetro. Por defecto el periodo es de 1 segundos');
gettext('Corazon_10Hz');
gettext('Bombear 10 bits por segundo');
gettext('Creado a partir de un **corazón  \ngenérico**, dando el valor adecuado  \na su parámetro frecuencia');
gettext('Corazon_1Hz');
gettext('Bombear 1 bit por segundo');
gettext('Corazon_1KHz');
gettext('Bombear 1000 bits por segundo');
gettext('Corazon_2Hz');
gettext('Bombear 2 bits por segundo');
gettext('Corazon_2KHz');
gettext('Bombear 2000 bits por segundo');
gettext('Corazon_3Hz');
gettext('Bombear 3 bits por segundo');
gettext('Corazon_4Hz');
gettext('Bombear 4 bits por segundo');
gettext('Corazon_5Hz');
gettext('Bombear 5 bits por segundo');
gettext('Corazon_7Hz');
gettext('Bombear 7 bits por segundo');
gettext('Corazon_DO4');
gettext('Bombear bits a la frecuencia del DO de la cuarta octava');
gettext('Corazon_MI4');
gettext('Bombear bits a la frecuencia del MI de la cuarta octava');
gettext('Corazon_RE4');
gettext('Bombear bits a la frecuencia del RE de la cuarta octava');
gettext('02_bits');
gettext('04_bits');
gettext('08_bits');
gettext('Agregador');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('Separador');
gettext('Separador de bus de 2-bits en dos cables');
gettext('Agregador');
gettext('Agregador de buses de 2-bits a bus de 4-bits');
gettext('Separador');
gettext('Separador de bus de 4-bits en buses de 2 bits');
gettext('Agregador');
gettext('Agregador de 2 buses de 4-bits a bus de 8-bits');
gettext('Separador');
gettext('Separador de bus de 8-bits en buses de 4 bits');
gettext('SM-S4303R');
gettext('MotorBit-param');
gettext('Controlador para servo de rotacion continua SprintRC SM-S4303R. Con on=1, el motor avanza. Dir=1 sentido agujas reloj/ 0 el contrario. V1 y V2 son los pulsos para las velocidades horaria y antihoraria (en micro-sec). V0 para que esté parado');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('**Velocidad 1**: Velocidad para el  \nsentido de giro horario\n');
gettext('**Velocidad 2**: Velocidad para el \nsentido de giro antirhorario');
gettext('**Entrada on/off**: Motor en  \nmovimiento o parado');
gettext('**Motorbit paramétrico** para los **SM-S4303R** o compatibles\n\nTiene 3 parámetros, especificados en micro-segundos. **V1** y **V2** son las posiciones (ancho del pulso)  \npara las velocidades de giro en sentido horario y antihorario respectivamente\n\n**V0** es la posición en la que el servo está parado (velocidad 0)\n\nPor defecto se asignan los valores para las velocidades máximas, tanto en sentido horario como antihorario\n\n* V1max = 1900\n* V2max = 1100\n* V0 = 1500');
gettext('**Velocidad en sentido horario**\n\n* Si V1 >= 1900, la velocidad es máxima\n* Si 1900 > V1 > 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**Velocidad en sentido antihorario**\n\n* Si V2 <= 1100, la velocidad es máxima\n* Si 1100 < V2 < 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**dir**: Sentido de giro  \n1: horario / 0: antihorario');
gettext('**Velocidad 0**: Posición para que  \nel servo esté parado');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('MotorBit');
gettext('Controlador para servo de rotacion continua SprintRC SM-S4303R. Con on=1, el motor avanza. Dir=1 sentido agujas reloj/ 0 el contrario');
gettext('Academia-Jedi');
gettext('Emojis');
gettext('Rusia-2018');
gettext('00-Pre');
gettext('01-Primero');
gettext('02-Segundo');
gettext('00-Observador');
gettext('Rango de Observador. Pre-academia Jedi');
gettext('01-Aspirante-a-Cadete');
gettext('Rango de Aspirante a Cadete. Pre-academia Jedi');
gettext('02-Cadete');
gettext('Rango de Cadete. Primer curso');
gettext('03-Cadete-N1');
gettext('Rango de Cadete Nivel 1. Primer curso');
gettext('04-Cadete-N2');
gettext('Rango de Cadete Nivel 2. Primer curso');
gettext('05-Cadete-N3');
gettext('Rango de Cadete Nivel 3. Primer curso');
gettext('06-Aspirante-Padawan');
gettext('Rango de Aspirante a Padawan. Primer curso');
gettext('07-Aspirante-Padawan-N1');
gettext('Rango de Aspirante a Padawan Nivel 1. Primer curso');
gettext('08-Aspirante-Padawan-N2');
gettext('Rango de Aspirante a Padawan Nivel 2. Primer curso');
gettext('09-Aspirante-Padawan-N3');
gettext('Rango de Aspirante a Padawan Nivel 3. Primer curso');
gettext('10-Padawan');
gettext('Rango de Padawan. Segundo curso');
gettext('11-Padawan-N1');
gettext('Rango de Padawan Nivel 1. Segundo curso');
gettext('12-Padawan-N2');
gettext('Rango de Padawan Nivel 2. Segundo curso');
gettext('13-Padawan-N3');
gettext('Rango de Padawan Nivel 3. Segundo curso');
gettext('14-Aspirante-Jedi');
gettext('Rango de Aspirante a Jedi. Segundo curso');
gettext('15-Aspirante-Jedi-N1');
gettext('Rango de Aspirante a Jedi Nivel 1. Segundo curso');
gettext('Smiley');
gettext('Stickers de Smiley');
gettext('caca');
gettext('Caca sonriente');
gettext('like');
gettext('Like');
gettext('Rusia-2018-Balon');
gettext('Balón del Mundial de Rusia 2018');
gettext('Rusia-2018-equipos');
gettext('Equipos participanetes en el Mundial de Rusia 2018');
gettext('Rusia-2018-logo-1');
gettext('Mundial de Rusia 2018');
gettext('Rusia-2018-logo-2');
gettext('Rusia-2018-spain-1');
gettext('La roja en el Mundial de Rusia 2018');
gettext('Rusia-2018-spain-2');
gettext('Escudo de la selección Española');
gettext('Rusia-2018-spain-3');
gettext('Camiseta de la selección Española');
gettext('comecocos');
gettext('Bloque de prueba para explicar conceptos. No hace nada');
gettext('Bloque de documentación, para explicar los  \nconceptos de puertos, parámeros, pines, cables  \ny buses en el tutorial 21');
gettext('Tortuga-2');
gettext('Divisor entre dos');
gettext('Biestable T síncrono, inicializado a 0');
gettext('Biestable T síncrono, inicializado por parametro INI');
gettext('Tortuga: Divisor entre 2\n\nImplementado a partir de un\nbiestable T síncrono');
gettext('Hacer que solo responda a los flancos\nde subida de la señal de entrada');
gettext('Emax-ES08A');
gettext('Futaba-3003');
gettext('TowerPro-SG90');
gettext('ServoBit-90');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a las 2 posiciones POS0 y POS1');
gettext('**Posición 1**: Posición del servo cuando  \nse introduce un 1\n\nEl valor por defecto es de 135 grados\n');
gettext('**Posición 0**: Posición del servo cuando  \nse introduce un 0\n\nEl valor por defecto es de 45 grados');
gettext('**Entrada**: posición a donde llevar  \nel servo (posición 0 ó 1)');
gettext('**Servobit paramétrico** para los microservos **EMAX-ES08A** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **580 usec**  \n* Extremo izquierdo **2550 usec**\n');
gettext('ServoBit');
gettext('Servobit-90');
gettext('ServoBit para Futaba 3003. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit paramétrico para Futaba 3003. Controlador de 1 bit para mover el servo a las 2 posiciones P0 y P1');
gettext('**Servobit** para Servos Futaba 3003 o comaptibles\nLas dos posiciones están distanciadas **90 grados**  \n\n* **Posicion 0**: 45 grados  \n* **Posicion 1**: 135 grados  ');
gettext('**Servobit paramétrico** para los microservos **Futaba 3003** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **380 usec**  \n* Extremo izquierdo **2410 usec**\n');
gettext('Servobit');
gettext('Servobit-90');
gettext('ServoBit para micrservo TowerPro-SG90. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('**Servobit paramétrico** para los microservos **TowerPro SG-90** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **500 usec**  \n* Extremo izquierdo **2350 usec**\n');
gettext('Servobit');
gettext('Retos');
gettext('Soluciones');
gettext('Reto-01');
gettext('# Reto 1: Cargar este circuito de pruebas en la FPGA\n\nLo primero será **aprender** a cargar circutos en la FPGA y comprobar  \nque todo está funcionando correctamente: Software instalado, conexiones bien...\n\n* Conecta la placa al USB\n* Dale a opción Herramientas/Cargar...');
gettext('* ¿Qué hace este circuito?');
gettext('Reto-02');
gettext('# Reto 2: Mi primer circuito: Encender un LED  \n\nLa tarjeta Icezum Alhambra tiene 8 LEDs en su parte izquierda, justo encima del  \nconector del USB. Estos LEDs se denotan por LED0 (el inferior) hasta LED7 (el  \nde la parte superior)\n\nHacer un circuito digital que deje el LED0 encendido\n\n* Tendrás que colocar un pin de salida, asignado al LED0\n* Tendrás que poner un bit a 1, y sacarlo por el pin');
gettext('Reto-03');
gettext('# Reto 3: Encender dos LEDs  \n\nHacer un circuito digital que deje encendidos los LEDs **0** y **7**');
gettext('Reto-04');
gettext('# Reto 4: LED parpadeante  \n\nHacer un circuito digital para que el **LED5** parpadee a la  \nFrecuencia de **1Hz**  \n\n**Consejo**: Utilizar un **corazón** de 1Hz para bombear los bits  \n(Menú Varios/Bombeo/Fijo)');
gettext('Reto-05');
gettext('# Reto 5: LEDs alternantes  \n\nHacer un circuito digital para que los LEDs **6** y **1** parpadeen  \n**alternativamente**, con una frecuencia de **2Hz**. El parpadeo  \nalternativo significa que mientras un LED está encendido, el otro  \nestá apagado\n\n**Consejo**: Utilizar una puerta NOT (Menú Comb/Puertas)');
gettext('Reto-06');
gettext('# Reto 6: LEDs alternantes, con frecuencia paramétrica\n\nHacer un circuito digital para que los LEDs **6** y **1** parpadeen  \n**alternativamente**, a la frecuencia de **8Hz**, establecida mediante un parámetro \n\n**Consejo**: Utilizar un corazón paramétrico (Varios/Bombeo/Corazon_Hz), y conectarle  \nuna constante en la parte superior (Básico/Constante), con el valor adecuado');
gettext('Reto-07');
gettext('# Reto 7: LEDs alternantes. Un segundo cada LED\n\nHacer un circuito digital para que los LEDs **7** y **0** parpadeen  \n**alternativamente**, estando cada LED encendido durante 1 segundo\n\n**Consejo**: Utilizar un corazón paramétrico en segundos (Varios/Bombeo/Corazon_Seg)\n');
gettext('Reto-08');
gettext('# Reto 8: Encender y apagar un LED con el pulsador\n\nLa tarjeta Icezum Alhambra tiene **2 pulsadores pequeños**, situados en la parte superior,   \ncerca de los LEDs. Estos pulsadores son las entradas **SW1** y **SW2**\n \nHacer un circuito digital que encienda el **LED0** mientras que se apriete el **pulsador SW1**. Al  \ndejar de apretar se apagará\n\n**Consejo**: Colocar un pin de entrada (Básico/Entrada), asignado al pulsador SW1\n');
gettext('Reto-09');
gettext('# Reto 9: Conectar dos pulsadores a los LEDs\n\nHacer un circuito digital para que el **LED4** se encienda mientras el pulsador **SW1** esté apretado y  \napagado en caso contrario. Además, el **pulsador SW2** controlará los LEDs 7 y 0. Cuando no está pulsado,  \nse enciende el **LED0** y el **LED7** está apgado. Cuando se aprieta sucede lo contrario: el **LED0** se  \napaga y el **LED7** se enciende\n');
gettext('Reto-10');
gettext('# Reto 10: Movimiento de Servo de Rotación continua con Pulsadores\n\nHacer un circuito digital para mover el **servo de rotación continua** (Motor) con **dos pulsadores**.  \nEl pulsador **SW1** controla si el motor está moviéndose (al apretarlo) o parado (no pulsado). El  \npulsador **SW2** controla el sentido de giro del motor: Al apretarlo gira hacia un sentido y al soltarlo  \nhacia el otro\n\n## Paso 1: Conectar el servo al pin 0 (D0)\nFíjate en la Icezum Alhambra. En la parte superior tiene unos \"pinchos\". Son los pines de datos, y es donde  \npodemos conectar sensores y actuadores externos. Conecta el servo al pin 0 (es el que está más a la derecha)\n\n**CUIDADO**: Fíjate en la polaridad. El servo tiene cables de tres colores: Negro, rojo y blanco, lo mismo que  \nlos pines de la Icezum. Conectar el servo de forma que cada cable esté en el pin de su color\n\n## Paso 2: Coloca el componente Motorbit\nEl bloque que permite mover el motor se llama Motorbit (Varios/Motor/SM-4303R/MotorBit). La salida hay que  \nconectarla a un pin de salida asociado a D0. Tiene dos entradas: una para encender/apagar el motor, y otra  \npara determinar el sentido de giro');
gettext('Reto-11');
gettext('# Reto 11: Movimiento de dos motores, con pulsadores\n\nHacer un circuito digital para mover los dos motores al pulsar SW1, en sentidos contrarios. \nAl soltar SW1 se pararán. Mientras está pulsado SW1, el pulsador SW2 permite cambiar el  \nsentido de giro de uno de ellos, de forma que con SW2 apretado giran en el mismo sentido,  \ny con SW2 no apretado en sentidos contrarios');
gettext('Reto-12');
gettext('# Reto 12: Ver el estado del Sensor Infrarrojo en un LED \n\nHacer un circuito digital que lea el sensor de infrarrojos y lo muestre en cualquiera de  \nlos LEDs de la Icezum Alhambra. Conectar el sensor al pin 13 (D13), con la polaridad  \ncorrecta');
gettext('Reto-13');
gettext('# Reto 13: Conectar dos sensores IR a LED0 y LED7 \n\nConectar dos sensores de infrarrojos a los pines 12 y 13 (D12 y D13) y mostrar su  \nestado en los LEDs 0 y 7 respectivamente');
gettext('Reto-14');
gettext('# Reto 14: Movimiento del Robot: Avance parada\n\nMontar el [robot Icebot](https://github.com/Obijuan/icebot/wiki). Conectar el motor derecho al pin D0 y  \nel izquierdo al D1. Diseñar un circuito digital para  \nque el robot avance durante 1 segundo y esté parado durante otro segundo\n\n**Consejo**: Utilizar un corazón paramétrico, con parámetro de 2 segundos');
gettext('Reto-15');
gettext('# Reto 15: Movimiento del Robot: Avance-Giro derecha\n\nHacer un circuito digital para que el robot se mueva hacia adelante 1 segundo y gire a la  \nderecha durante otro segundo. Para hacer el giro, la rueda derecha debe estar parada y la  \nizquierda girando. Durante el avance las dos deben estar girando, cada una en un sentido\n');
gettext('Reto-16');
gettext('# Reto 16: Movimiento del Robot: Avance-Parado con sensor IR\n\nConectar un sensor de IR al pin D13. Lo utilizaremos como si fuese un pulsador. Cuando  \npongamos el dedo encima, tapándolo el robot se moverá hacia adelante. Cuando retiremos el  \ndedo y no tapemos el sensor, el robot estará parado\n');
gettext('Reto-17');
gettext('# Reto 17: Control manual del robot con los Sensores IR\n\nConectamos los dos sensores, el izquierdo al pin D13 y el derecho al D12. Diseñar un  \ncircuito digital para que el robot haga los **movimientos descritos en la tabla**, en  \nfunción de los dos sensores de IR. Cuando colocamos el dedo delante del sensor IR diremos que  \nestá pulsado (como si fuese un pulsador)\n\n');
gettext('En esta tabla se muestra el **comportamiento del robot**\n\n| Sensor izquierdo | Sensor derecho | Rueda derecha | Rueda izquierda |\n|------------------|----------------|---------------|-----------------|\n| NO Pulsado       |  No Pulsado    |   Parada      |  Parada         |\n| NO pulsado       |  Pulsado       |   Parada      |  Adelante       |\n| Pulsado          |  No pulsado    |   Adelante    |  Parada         |\n| Pulsado          |  Pulsado       |   Parada      |  Adelante       |\n');
gettext('Reto-18');
gettext('# Reto 18: Robot seguidor de objetos\n\nColocar los sensores de Infrarrojos en la parte frontal del robot, usando una goma  \nelástica. Diseñar un circuito digital que haga que el robot siga un objeto que tenga  \nsituado delante. En la siguiente tabla se resume el comportamiento\n\n');
gettext('**comportamiento del robot**\n\n| Sensor izquierdo | Sensor derecho | Rueda derecha | Rueda izquierda |\n|------------------|----------------|---------------|-----------------|\n| NO Pulsado       |  No Pulsado    |   Parada      |  Parada         |\n| NO pulsado       |  Pulsado       |   Parada      |  Adelante       |\n| Pulsado          |  No pulsado    |   Adelante    |  Parada         |\n| Pulsado          |  Pulsado       |   Parada      |  Adelante       |\n');
gettext('Reto-19');
gettext('# Reto 19: Robot lapa fantástico\n\nHacer que el robot siga un obstáculo mientras que los LEDs realizan  \nla secuencia de la serie \"El coche fantástico\"\n\n**Consejo**: Pegar el circuito del Reto 1 al del reto 18. En hardware, los  \ncircuitos van en paralelo y funcionan simultaneamente');
gettext('Sol-Reto-01');
gettext('# SOLUCIÓN');
gettext('**Hace que los LEDs de la tarjeta Icezum Alhambra luzcan siguiente la  \nsecuencia del frontal de KITT, el mítico coche de la serie ochentera de el  \ncoche fantástico** :-)');
gettext('Sol-Reto-02');
gettext('Pin de salida');
gettext('Un bit a 1 (constante)');
gettext('Cable de conexión, para que el  \nBit a 1 salgo por el pin');
gettext('Sol-Reto-03');
gettext('# SOLUCIÓN 1\n\nPoniendo dos circuitos iguales que los del reto 1');
gettext('# SOLUCIÓN 2\n\nUsando un único Bit a 1 contante, conectado a los pines  \npor dos cables');
gettext('**Nota**: En la solución 2 se han cambiado los LEDs  \nporque no puede haber pines duplicados');
gettext('Sol-Reto-04');
gettext('# SOLUCIÓN\n\n');
gettext('Sol-Reto-05');
gettext('Sol-Reto-06');
gettext('Este corazón tiene una entrada en la parte superior, para dar valor  \nal parámetro frecuencia. Este parámetro NO está conectado por un cable  \nfísico real, sino que permite crear un corazón de frecuencia fija 8Hz,\nque luego se sintetia en la FPGA');
gettext('Sol-Reto-07');
gettext('Para que cada LED esté encendido durante 1 segundo, hay que  \nusar un **periodo de 2 segundos**. Es el valor que ponemos en  \nel parámetro del corazón');
gettext('Sol-Reto-08');
gettext('El circuito es un simple **cable**, que conecta el pulsador de  \nentrada con el LED de salida');
gettext('Pin de entrada, asociado al  \npulsador SW1');
gettext('Al apretar el pulsador entra un Bit a 1, que llega hasta  \nel LED0 a través del cable, encendiéndolo. Cuando no está  \napretado, hay un Bit a 0, que hace que el LED0 se apague');
gettext('Sol-Reto-09');
gettext('Sol-Reto-10');
gettext('Controlador del motor');
gettext('Pin donde está conectado el servo');
gettext('Sol-Reto-11');
gettext('Sol-Reto-12');
gettext('El circuito es muy sencillo. Basta con conectar un cable entre la  \nentrada donde está conectado el sensor (D13) y la salida donde está  \nel LED');
gettext('Sol-Reto-13');
gettext('Sol-Reto-14');
gettext('**Rueda izquierda**');
gettext('**Rueda Derecha**');
gettext('Rueda izquierda siempre en movimiento');
gettext('Rueda derecha está un tiempo adelante, y un  \ntiempo parada');
gettext('Sol-Reto-15');
gettext('Sol-Reto-16');
gettext('Sol-Reto-17');
gettext('**Sensor izquierdo**');
gettext('**Sensor derecho**');
gettext('Sol-Reto-18');
gettext('Sol-Reto-19');
